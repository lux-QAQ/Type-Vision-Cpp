// This file is generated by generate_parsers.py. DO NOT EDIT MANUALLY.

template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, false, false, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) &>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, false, true, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) & noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, false, true, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) &&>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, false, false, true, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) && noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, false, false, true, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, false, false, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, false, false, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const &>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, false, true, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const & noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, false, true, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const &&>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, false, false, true, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const && noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, false, false, true, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) volatile>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, true, false, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) volatile noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, true, false, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) volatile &>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, true, true, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) volatile & noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, true, true, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) volatile &&>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, true, false, true, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) volatile && noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<false, true, false, true, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const volatile>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, true, false, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const volatile noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, true, false, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const volatile &>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, true, true, false, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const volatile & noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, true, true, false, true>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const volatile &&>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, true, false, true, false>>;
};
template <typename R, typename C, typename... Args>
struct Parser<R (C::*)(Args...) const volatile && noexcept>
{
    using type = StaticMemberFunctionPointer<typename Parser<C>::type, typename Parser<R>::type, std::tuple<typename Parser<Args>::type...>, Qualifiers<true, true, false, true, true>>;
};
