// This file is generated by generate_lambda_parsers.py. DO NOT EDIT MANUALLY.

template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) &>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) & noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) &&>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) && noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const &>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const & noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const &&>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const && noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = false;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) volatile>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) volatile noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) volatile &>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) volatile & noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) volatile &&>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) volatile && noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = false;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const volatile>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const volatile noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const volatile &>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const volatile & noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = true;
    static constexpr bool is_rvalue_ref = false;
    static constexpr bool is_noexcept = true;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const volatile &&>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = false;
};
template <typename R, typename C, typename... Args>
struct lambda_signature_parser<R (C::*)(Args...) const volatile && noexcept>
{
    using return_type = R;
    using args_tuple = std::tuple<Args...>;
    static constexpr bool is_const = true;
    static constexpr bool is_volatile = true;
    static constexpr bool is_lvalue_ref = false;
    static constexpr bool is_rvalue_ref = true;
    static constexpr bool is_noexcept = true;
};