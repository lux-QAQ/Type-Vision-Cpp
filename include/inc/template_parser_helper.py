import os

def generate_helpers(max_args=10, output_file="template_parser_helper.inc"):
    """
    为 template_parser_helper 生成 C++ 模板特化，
    覆盖最多 max_args 个参数的所有 'typename' 和 'auto' 组合。
    """
    with open(output_file, "w") as f:
        f.write("// This file is generated by template_parser_helper.py. DO NOT EDIT.\n\n")

        for n in range(1, max_args + 1):
            f.write(f"// --- {n} argument{'s' if n > 1 else ''} ---\n")
            # 遍历所有 2^n 种组合
            for i in range(2**n):
                param_kinds = []
                param_defs = []
                param_names = []
                wrapper_types = []

                # 为当前组合构建参数列表
                for j in range(n):
                    # 检查 i 的第 j 位。0 代表 typename, 1 代表 auto。
                    if (i >> j) & 1 == 0:  # typename
                        param_kinds.append("typename")
                        param_defs.append(f"typename T{j + 1}")
                        param_names.append(f"T{j + 1}")
                        wrapper_types.append(f"type_wrapper<T{j + 1}>")
                    else:  # auto
                        param_kinds.append("auto")
                        param_defs.append(f"auto V{j + 1}")
                        param_names.append(f"V{j + 1}")
                        wrapper_types.append(f"value_wrapper<V{j + 1}>")

                # 将列表连接成字符串
                param_kinds_str = ", ".join(param_kinds)
                param_defs_str = ", ".join(param_defs)
                param_names_str = ", ".join(param_names)
                wrapper_types_str = ", ".join(wrapper_types)

                # 将 C++ 模板特化代码写入文件
                f.write(f"template <template <{param_kinds_str}> class C, {param_defs_str}>\n")
                f.write(f"struct template_parser_helper<C<{param_names_str}>>\n")
                f.write("{\n")
                f.write("    static constexpr bool is_specialization = true;\n")
                f.write(f"    using args_as_tuple = std::tuple<{wrapper_types_str}>;\n")
                f.write("};\n\n")
            f.write("\n")

if __name__ == "__main__":
    # 获取脚本所在的目录
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # 将输出文件路径设置为脚本的同级目录
    output_path = os.path.join(script_dir, "template_parser_helper.inc")
    
    print(f"Generating template helpers to {output_path}...")
    generate_helpers(max_args=11, output_file=output_path)
    print("Generation complete.")
    # 数量再多编译器吃不消了